---
title: 最长上升子序列
date: 2022-02-19 18:14:40
categories: 算法提高课
tags: Acwing
cover: /img/acwing_logo.png
---



# AcWing 1010. 拦截导弹

## 题目分析：

第一问是裸的最长上升子序列。

第二问是该数组最少能被几个不升子序列全部覆盖

> 数据范围 ：雷达给出的高度数据是不大于 30000 的正整数，导弹数不超过 1000。

**输入样例**

```
389 207 155 300 299 170 158 65
```

**输出样例**

```
6
2
```



### 贪心解法：

从前往后扫描每一个数，对于每一个数：

1. 如果现有的自学列的结尾都小于当前数，则常见新子序列
2. 将当前数放到结尾大于等于他的最小的子序列后面

用一个数字即每套拦截系统此时所拦截的最后一个导弹高度，来表示该系统。

这样就得到了一个数组 `g[]`，数组最终长度就是所需最少拦截系统数目。

代码

```c++
// cnt 表示当前有几套系统
//数组g的每个元素代表一套导弹拦截系统的拦截序列
//g[i]表示此时第i套导弹拦截系统所拦截的最后一个导弹的高度
int p = lower_bound(g, g+cnt, a[i]) - g;
if(p == cnt) g[cnt ++] = a[i];  //a[i]开创一套新拦截系统    
else g[p] = a[i];               //a[i]成为第p套拦截系统最后一个导弹高度
```

贪心解法可以引申到最长上升子序列的贪心解法，复杂度为 `O(nlog n)`

以下是**严格单调递增**的子序列的长度最长的代码。

```c++
int LIS(){
    int len=1;
    g[1]=a[1];
    for(int i=2;i<=n;i++){
        if(a[i]>g[len]){
            g[++len]=a[i];
        }
        else{
            int pos=lower_bound(g+1,g+len+1,a[i])-g;
            g[pos]=a[i];
        }
    }
    return len;
}
```

**解析：**

首先数组a中存输入的数（原本的数），开辟一个数组g用来存结果，最终数组g的长度就是最终的答案；

假如数组g现在存了数，当到了数组a的第i个位置时，首先判断a[i] > g[len] ？ 若是大于则直接将这个数添加到数组g中，即f[++len] = a[i];这个操作时显然的。

当a[i] <= g[len] 的时,我们就用a[i]去替代数组g中的第一个大于等于a[i]的数，因为在整个过程中我们维护的数组g 是一个递增的数组，所以我们可以用二分查找在 `log n` 的时间复杂的的情况下直接找到对应的位置`pos`，然后替换，即g[pos] = a[i]。

为什么可以用a[i]去替代数组g中的第一个大于等于a[i]的数`g[pos]`呢？

1. `g[pos]` > = `a[i]` , 所以替换之后子序列的长度不会减少，不会影响pos 之前的数
2. `g[pos]` 变小了，后面的可以放的数字就会变多

### DP解法：

第二问求导弹拦截系统的个数可以转化为求最长上升子序列长度

> 1、首先我们把这些导弹分为s组（s即为所求答案）
> 可以看出每一组都是一个不升子序列
> 2、划分完后我们在组一里找一个原序列里以组一的开头点连续的不升子串的最后一个元素，可以知道在组2中一定有一个大与它的点
> （如果组二中没有的话，那么组二中最高的导弹高度必然小于这个点，而其他的高度都小于这个高度而且是递减或相等的，那么没有必要再开一个组二了，矛盾，所以不存在找不到比他大的点的情况）
> 3、以此类推，对于每一个k组（1<=k<n）都可以找到这样的一些点
> 所以把这些点连起来，就是一条上升子序列。
> 4、设最长上升子序列长度为l
> 所求上升子序列为h
> 那么h<=l
> 因为最长上升子序列任意两个不在一组内
> (如果在同一个组内，则每个组的数不成为一个不生子序列，矛盾）
> 所以l==h
>
> 比较难理解
> 我们来看组数据
> 389 207 155 300 299 170 158 65
> 组一 389 207 155 65 组二 300 299 170 158
> 步骤一中我们一开始找到的点是1
> 因为如果找65不好解释，所以我们找原数列里连续的最后一个即155
> 组二里可以找到300比他大
> 所以最长上升子序列长度为2==答案
>
> 作者：空空如也
> 链接：https://www.acwing.com/solution/content/10173/
> 来源：AcWing
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



### Conclusion

数组最少能被几个不升子序列全部覆盖 和 数组的最长上升子序列长度  互为对偶问题，因此本题有两种做法，前者采用贪心（`O(n log n)`）,后者是DP（`O(n^2)`）。

**Binary Search ~~WF 算法~~**

二分程序虽然简单，但是如果写之前不考虑好想要查找的是什么，十有八九会是死循环或者查找错误，就算侥幸写对了也只是运气好而已。用二分去查找元素要求数组的有序性或者拥有类似于有序的性质，

解题的时候往往会考虑枚举答案然后检验枚举的值是否正确。若满足单调性，则满足使用二分法的条件。把这里的枚举换成二分，就变成了“二分答案”。

STL:

若数组升序排列
`lower_bound(begin, end, a)` 返回数组[begin, end)之间第一个大于或等于a的地址，找不到返回end ~~（可以等于所以low）~~
`upper_bound(begin, end, a) `返回数组[begin, end)之间第一个大于a的地址，找不到返回end ~~（一定大于所以up）~~

若数组降序排列，可写上比较函数`greater<type>()`
`lower_bound(begin, end, a, greater<int>()) `返回数组[begin, end)之间第一个小于或等于a的地址，找不到返回end
`upper_bound(begin, end, a, greater<int>()) `返回数组[begin, end)之间第一个小于a的地址，找不到返回end

yxc 版：

```c++
int l = 0, r = n - 1;
while (l < r) {
    int mid = l + r >> 1;
    if (a[mid] < x)  l = mid + 1;
    else    r = mid;
}
```

