---
title: 背包模型
date: 2022-02-23 21:48:57
categories: 算法提高课
tags: Acwing
cover: /img/acwing_logo.png
---



崔添翼的[《背包问题九讲》](https://www.selfknow.cn/document/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2.pdf)



## 01背包

有$n(1\le n \le1000)$  个物品要放到一个袋子里，袋子的总容量为$m(1\le m \le 1000)$  ，第 $i$ 个物品的体积为 $v_i(1\le v_i\le1000)$ ，把它放进袋子里会获得 $w_i(1\le w_i \le1000)$的收益，**每种物品只能用一次**，问如何选择物品，使得在物品的总体积不超过$m$的情况下，获得最大的收益？请求出最大收益。



$$
DP
\begin{cases} 
状态表示f[i][j]
	\begin{cases} 集合：所有从前 i 个物品中选，且总体积(代价)不超过 j 的选法的集合
    \\ \\
    属性：Max
    \end{cases}
\\ \\
状态计算--集合的划分：
\begin{cases} 不选择第i个物品的所有方案
    \\ \\
    选择第 i 个物品的所有方案
    \end{cases}
\end{cases}
$$


> $f[i][j] = max(f[i-1][j]，f[i-1][j-v[i]]+w[i])$
>
> 恒等变换：
>
> $f[j]=\max(f[j],f[j-v[i]]+w[i])$

```c++
#include<bits/stdc++.h>

using namespace std;

const int MAXN = 1005;
int v[MAXN];    // 体积
int w[MAXN];    // 价值 
int f[MAXN][MAXN];  // f[i][j], j体积下前i个物品的最大价值 

int main() 
{
    int n, m;   
    cin >> n >> m;
    for(int i = 1; i <= n; i++) 
        cin >> v[i] >> w[i];

    for(int i = 1; i <= n; i++) 
        for(int j = 1; j <= m; j++)
        {
            //  当前背包容量装不进第i个物品，则价值等于前i-1个物品
            if(j < v[i]) 
                f[i][j] = f[i - 1][j];
            // 能装，需进行决策是否选择第i个物品
            else    
                f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);
        }           

    cout << f[n][m] << endl;

    return 0;
}

```

一维情况正序更新状态f[j]需要用到前面计算的状态已经被「污染」，逆序则不会有这样的问题。

> 「污染」：原本需要用上一层的状态更新$f[j]$，如果正序更新的话，已经到本层的状态了。

一维版本

```c++
for(int i = 1; i <= n; i++)
{
    for(int j = m; j >= v[i]; j--)  
        f[j] = max(f[j], f[j - v[i]] + w[i]);
} 
```

二维下的状态定义$f[i][j]$是前$ i $件物品，背包容量 $j$下的最大价值。一维下，少了前 $i$ 件物品这个维度，我们的代码中决策到第 $i$件物品（循环到第$i$轮），$f[j]$就是前$i$轮已经决策的物品且背包容量$j$下的最大价值。

因此当执行完循环结构后，由于已经决策了所有物品，$f[j]$ 就是所有物品背包容量$j$下的最大价值。即一维$f[j]$等价于二维$f[n][j]$。

## 完全背包

有$n(1\le n \le1000)$  个物品要放到一个袋子里，袋子的总容量为$m(1\le m \le 1000)$  ，第 $i$ 个物品的体积为 $v_i(1\le v_i\le1000)$ ，把它放进袋子里会获得 $w_i(1\le w_i \le1000)$的收益，**每种物品能用无限多次**，问如何选择物品，使得在物品的总体积不超过$m$的情况下，获得最大的收益？请求出最大收益。

```c++
/*
状态是从f[i-1][j] 和 f[i][j-v]（本层的）转移过来的
*/ 
for(int i = 1 ; i<=n ;i++)
    for(int j = v[i] ; j<=m ;j++)
    {
            f[j] = max(f[j],f[j-v[i]]+w[i]);
    }
```



## 多重背包

有 $N$ 种物品和一个容量是$ V$ 的背包。

第 $i $种物品最多有 $s_i$ 件，每件体积是 $v_i$，价值是$ w_i$。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
输出最大价值。

```c++
#include <bits/stdc++.h>
using namespace std;
int n,m,dp[10005];
int w,v,s;
int main()
{
    cin>>n>>m;
    while(n--){
        cin>>v>>w>>s;
        while(s--){
            for(int j=m;j>=v;j--)
                dp[j]=max(dp[j-v]+w,dp[j]);//直接套01背包的板子
        }
    }
    cout<<dp[m]<<endl;
    return 0;
}

```

二进制优化：

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 2010;
int f[N],n,m;
struct good
{
    int w,v;
};

int main()
{
    cin>>n>>m;
    vector<good> Good;
    good tmp;

    //二进制处理
    for(int i = 1 ; i <= n ; i++ )
    {
        int v,w,s;
        cin>>v>>w>>s;
        //坑,k <= s
        for(int k = 1 ; k <= s ; k*=2 )
        {
            s-=k;
            Good.push_back({k*w,k*v});
        }
        if(s>0) Good.push_back({s*w,s*v});
    }

    //01背包优化+二进制
    for(auto t : Good)
        for(int j = m ; j >= t.v ; j--)
            f[j] = max(f[j] , f[j-t.v]+t.w ); //这里就是f[j]


    cout<<f[m]<<endl;
    return 0;

}

```





## 分组背包





```c++
#include<bits/stdc++.h>
using namespace std;

const int N=110;
int f[N][N];  //只从前i组物品中选，当前体积小于等于j的最大值
int v[N][N],w[N][N],s[N];   //v为体积，w为价值，s代表第i组物品的个数
int n,m,k;

int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>s[i];
        for(int j=0;j<s[i];j++){
            cin>>v[i][j]>>w[i][j];  //读入
        }
    }

    for(int i=1;i<=n;i++){
        for(int j=0;j<=m;j++){
            f[i][j]=f[i-1][j];  //不选
            for(int k=0;k<s[i];k++){
                if(j>=v[i][k])     f[i][j]=max(f[i][j],f[i-1][j-v[i][k]]+w[i][k]);  
            }
        }
    }
    cout<<f[n][m]<<endl;
}


```



一维版本

```c++
for(int i=0;i<n;i++)
    for(int j=m;j>=0;j--)
        for(int k=0;k<s[i];k++)
            if(j>=v[i][k])
                f[j]=max(f[j],f[j-v[i][k]]+w[i][k]); 

```



Conclusion:

```c++
背包问题：
    
先枚举物品
    再枚举代价
    	再枚举决策
```



1. 01背包：每个物品：选或不选
2. 完全背包：每个物品：选 0 个，选 1 个，选 2 个 ....
3. 多重背包：把$s[i]$个物品拆成一个一伙的，$s[i]$ 个当01背包做
